class AbstractCANIX:
  """
  This class is an abstract class and typically is subclassed by CANIX.
  When in Linux one should use the CANIX class found in pcan_linux.py, when
  you're a PC you will use the CANIX class in pcan_win.py

  This concrete class provides all the functionality needed to send and 
  receive messages using the CANbus protocol.

  pcan is autogenerated from the PCAN driver header using pcanopener.py
  pcan execfiles this module. Documentation on the driver can be
  found here:
    http://www.peak-system.com/fileadmin/media/linux/index.htm
  Typical usage consists of opening a CANbus and writing a message:
    >>> can = CANIX()
    >>> errno = can.init()
    >>> ID = 0x01;
    >>> MSGTYPE = MSGTYPE_STANDARD;
    >>> msg = Msg(ID,MSGTYPE,len(DATA),DATA);
    >>> errno = can.write(pointer(msg));
    >>> errno = can.read(pointer(msg));
    >>> errno = can.close()
  """

  def init(self, baudrate_code, msgtype, dev):
    """
    CAN_Init()
    initializes the CAN hardware with the BTR0 + BTR1 constant "CAN_BAUD_...".
    nCANMsgType must be filled with "CAN_INIT_TYPE_..".
    The default initialisation, e.g. CAN_Init is not called,
    is 500 kbit/sec and extended frames.
    """
    abstract

  def resetfilter(self):
    """
    CAN_ResetFilter() - removes all current Message Filters
    Caution! Currently this operation influences all read paths
    """
    abstract

  def msgfilter(self, from_id, to_id, can_msg_type):
    """
    CAN_MsgFilter() - reduce received data in to FromID <= ID <= ToID
    Type may be MSGTYPE_STANDARD or MSGTYPE_EXTENDED
    This function can be called multiple to add more ranges.
    Caution! Currently this operation influences all read paths
    """
    abstract


  def close(self):
    """
    CAN_Close()
    closes the path to the CAN hardware.
    The last close on the hardware put the chip into passive state.
    """
    abstract
            
  def status(self):
    """
    CAN_Status()
    request the current (stored) status of the CAN hardware. After the read 
    the stored status is reset.
    If the status is negative a system error is returned (e.g. -EBADF).
    """
    abstract
      
  def write(self, msg_pointer):
    """
    LINUX_CAN_Write_Timeout()
    writes a message to the CAN bus. If the (software) message buffer is full
    the current write request blocks until a write slot gets empty 
    or a timeout or a error occures.
    nMicroSeconds  > 0 -> Timeout in microseconds
    nMicroSeconds == 0 -> polling
    nMicroSeconds  < 0 -> blocking, same as CAN_Write()
    """
    abstract

  def read(self, msg_pointer):
    """
    reads a message from the CAN bus. If there is no message to read the 
    current request blocks until either a new message arrives or a error 
    occurs.
    """
    abstract

import re
import sys

mswindows = (sys.platform == "win32")

print "Redirecting output to pcan.py"
OUTPUT = open("pcan.py","w")
temp = sys.stdout
sys.stdout = OUTPUT

## regex for #define-s like these
# #define HW_DONGLE_SJA_EPP  6 
# #define HW_DONGLE_PRO      7 // not yet supported with LINUX
# #define CAN_ERR_OK             0x0000  // no error
RE_DEF = re.compile('#define\s+(\w+)\s+((0x([0-9a-fA-F])+)|(\d+))')

## regex for field declarations in structs, e.g.
#  BYTE  LEN;             // count of data bytes (0..8)
#  BYTE  DATA[8];         // data bytes, up to 8
RE_FIELD = re.compile('\s*(\w+)\s+(\w+)(?:\[(\w+)\])?;\s*(?:// (.*))?')

## regex for typedef struct 
RE_BEGIN = re.compile('\s*typedef\s+struct')

## regex for struct name with TP prefix
RE_END = re.compile('[}]\s+(TP\w+)\s*;\s*(?:// (.*))?')

## regex for function declaration
if mswindows:
	RE_FUN = re.compile('\w+\s+\w+\s+(\w+)[(]')
else:
	RE_FUN = re.compile('\w+\s+(\w+)[(]')

# Storage for #defines
defs = []
# Storage for structs
strc = {}
# Function names
funs = []
# Loop over the 'pcan.h' file
if mswindows:
	dev = 'Pcan_usb.h'
else:
	dev = '/usr/include/pcan.h'
for line in open(dev,'r'):
  m = RE_DEF.match(line)
  if m:
    #print "DEF",m.groups()
    defs.append(m.groups())
    continue
  m = RE_BEGIN.match(line)
  if m:
    #print "BEGIN"
    stmp = []
    continue    
  m = RE_FIELD.match(line)
  if m:
    #print "FIELD",m.groups()
    stmp.append(m.groups())
    continue    
  m = RE_END.match(line)
  if m:
    #print "END",m.groups()
    strc[m.group(1)] = (m.groups()[1:],stmp)
    continue
  if mswindows:
	  m = RE_FUN.match(line)
	  if m:
		funs.append(m.group(1))
		continue


if not mswindows:    
  # Scan libpcan.h
  for line in open("/usr/include/libpcan.h","r"):
    m = RE_DEF.match(line)
    if m:
      #print "DEF",m.groups()
      defs.append(m.groups())
      continue
    m = RE_FUN.match(line)
    if m:
      funs.append(m.group(1))
      continue
  
# Type conversions
cvt = { 
    'DWORD' : 'c_uint', 
    'WORD' : 'c_ushort', 
    'BYTE' : 'c_ubyte',
    'int' : 'c_int',
    'char' : 'c_char' }
    
## Start generating output python code

print """# WARNING: this file was autogenerated from pcan.h and libpcan.h
from ctypes import *
"""

# Define all constants
for d in defs:
  nm,val = d[:2]
  if nm[:4]=="CAN_":
    print nm[4:],'=',val
  else:
    print nm,'=',val
    

# Create a ctypes.Structure subclass for each struct
snm={}
for nm,(dsc,body) in strc.iteritems():
  print
  # Create a short name
  if nm[:5]=="TPCAN":
    snm[nm] = nm[5:]
  elif nm[:2]=="TP":
    snm[nm] = nm[2:]
  else:
    snm[nm] = nm
  print "class %s( Structure ):" % snm[nm]
  print '  """%s"""' % dsc
  print "  _fields_ = ["
  for ty,nm,num,doc in body:
    if num is None:
      print "    ('%s',%s)," % (nm,cvt.get(ty,snm.get(ty,ty))),"#",doc
    else:
      print "    ('%s',%s * %s)," % (nm,cvt.get(ty,snm.get(ty,ty)),num),"#",doc
  print "  ]"
  

# Create a ctypes.Union of all subclasses and also a flat char array
print "class PCAN( Union ):"
print '  """Union of all PCAN structures from pcan.h"""'
print '  _fields_ = ['
for nm in strc.iterkeys():
  print "    ('as%s',%s)," % (snm[nm],snm[nm])
print "    ('raw',c_char * 128)"
print '  ]'

# Access the libpcan library
if mswindows:
	print "\nlib = windll.LoadLibrary('Pcan_usb.dll')"
else:
	print "\nlib = cdll.LoadLibrary('libpcan.so')"
# Create nice namespace for CAN 
print "\nclass CAN(object):"
print '  """Namespace for CAN functions of libpcan.h"""'
for fn in (f for f in funs if f[:4]=='CAN_'):
  sys.stderr.write(fn + '\n')
  if mswindows:
    if fn in ['CAN_ReadEx','CAN_DLLVersionInfo','CAN_SetRcvEvent']:
      continue #bug workaround, header broken
  print "  %s = lib.%s" % (fn[4:].lower(),fn)

if not mswindows:
  print "\nclass LICAN(object):"
  print '  """Namespace for LINUX_CAN functions of libpcan.h"""'
  for fn in (f for f in funs if f[:10]=='LINUX_CAN_'):
    print "  %s = lib.%s" % (fn[10:].lower(),fn)

if mswindows:
  print "\nfrom pcan_win import *"
else:
  print "\nfrom pcan_linux import *" 
#J what's the difference execfile or import? I need to do this to get import from a different directory to work like ./examples/servosettings.py

sys.stdout = temp
OUTPUT.close()
